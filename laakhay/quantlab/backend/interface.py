"""Backend interface."""

from __future__ import annotations

from ..types import Array, Axis, Shape
from .device import Device


class Backend:
    """Backend protocol for array operations."""

    name: str

    def to_device(self, array: Array, device: Device) -> Array: ...
    def device(self, array: Array) -> Device: ...
    def is_gpu_available(self) -> bool: ...

    def array(
        self, data: any, dtype: any = None, device: Device | None = None
    ) -> Array: ...
    def zeros(
        self, shape: Shape, dtype: any = None, device: Device | None = None
    ) -> Array: ...
    def ones(
        self, shape: Shape, dtype: any = None, device: Device | None = None
    ) -> Array: ...
    def full(
        self,
        shape: Shape,
        value: float,
        dtype: any = None,
        device: Device | None = None,
    ) -> Array: ...
    def arange(
        self, *args, dtype: any = None, device: Device | None = None
    ) -> Array: ...
    def linspace(
        self,
        start: float,
        stop: float,
        num: int = 50,
        device: Device | None = None,
    ) -> Array: ...
    def eye(
        self, n: int, m: int | None = None, device: Device | None = None
    ) -> Array: ...

    def random_key(self, seed: int) -> any: ...
    def random_normal(
        self,
        key: any,
        shape: Shape,
        dtype: any = None,
        device: Device | None = None,
    ) -> Array: ...
    def random_uniform(
        self,
        key: any,
        shape: Shape,
        low: float = 0.0,
        high: float = 1.0,
        dtype: any = None,
        device: Device | None = None,
    ) -> Array: ...
    def random_split(self, key: any, num: int = 2) -> list[any]: ...

    def reshape(self, a: Array, shape: Shape) -> Array: ...
    def transpose(self, a: Array, axes: list[int] | None = None) -> Array: ...
    def concat(self, arrays: list[Array], axis: int = 0) -> Array: ...
    def stack(self, arrays: list[Array], axis: int = 0) -> Array: ...
    def split(
        self, a: Array, indices: int | list[int], axis: int = 0
    ) -> list[Array]: ...
    def squeeze(self, a: Array, axis: Axis = None) -> Array: ...
    def expand_dims(self, a: Array, axis: int) -> Array: ...

    def sum(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...
    def mean(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...
    def std(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...
    def var(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...
    def min(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...
    def max(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...
    def argmin(self, a: Array, axis: Axis = None) -> Array: ...
    def argmax(self, a: Array, axis: Axis = None) -> Array: ...
    def prod(self, a: Array, axis: Axis = None, keepdims: bool = False) -> Array: ...

    def add(self, a: Array, b: Array) -> Array: ...
    def sub(self, a: Array, b: Array) -> Array: ...
    def mul(self, a: Array, b: Array) -> Array: ...
    def div(self, a: Array, b: Array) -> Array: ...
    def pow(self, a: Array, b: Array) -> Array: ...
    def matmul(self, a: Array, b: Array) -> Array: ...
    def dot(self, a: Array, b: Array) -> Array: ...

    def abs(self, a: Array) -> Array: ...
    def sign(self, a: Array) -> Array: ...
    def exp(self, a: Array) -> Array: ...
    def log(self, a: Array) -> Array: ...
    def log10(self, a: Array) -> Array: ...
    def sqrt(self, a: Array) -> Array: ...
    def sin(self, a: Array) -> Array: ...
    def cos(self, a: Array) -> Array: ...
    def tan(self, a: Array) -> Array: ...
    def tanh(self, a: Array) -> Array: ...
    def sinh(self, a: Array) -> Array: ...
    def cosh(self, a: Array) -> Array: ...

    def norm_cdf(self, x: Array) -> Array: ...
    def norm_pdf(self, x: Array) -> Array: ...
    def norm_ppf(self, q: Array) -> Array: ...
    def erf(self, x: Array) -> Array: ...
    def erfc(self, x: Array) -> Array: ...
    def gamma(self, x: Array) -> Array: ...
    def lgamma(self, x: Array) -> Array: ...

    def eq(self, a: Array, b: Array) -> Array: ...
    def ne(self, a: Array, b: Array) -> Array: ...
    def lt(self, a: Array, b: Array) -> Array: ...
    def le(self, a: Array, b: Array) -> Array: ...
    def gt(self, a: Array, b: Array) -> Array: ...
    def ge(self, a: Array, b: Array) -> Array: ...
    def isnan(self, a: Array) -> Array: ...
    def isinf(self, a: Array) -> Array: ...
    def isfinite(self, a: Array) -> Array: ...

    def where(self, cond: Array, x: Array, y: Array) -> Array: ...
    def clip(
        self, a: Array, min: float | None = None, max: float | None = None
    ) -> Array: ...
    def maximum(self, a: Array, b: Array) -> Array: ...
    def minimum(self, a: Array, b: Array) -> Array: ...

    def cholesky(self, a: Array) -> Array: ...
    def solve(self, a: Array, b: Array) -> Array: ...
    def inv(self, a: Array) -> Array: ...
    def det(self, a: Array) -> Array: ...
    def eig(self, a: Array) -> tuple[Array, Array]: ...
    def svd(
        self, a: Array, full_matrices: bool = True
    ) -> tuple[Array, Array, Array]: ...
    def qr(self, a: Array) -> tuple[Array, Array]: ...
    def norm(self, a: Array, ord: any = None, axis: Axis = None) -> Array: ...

    def shape(self, a: Array) -> Shape: ...
    def dtype(self, a: Array) -> any: ...
    def ndim(self, a: Array) -> int: ...
    def size(self, a: Array) -> int: ...
    def is_array(self, obj: any) -> bool: ...

    def to_numpy(self, a: Array) -> Array: ...
    def from_numpy(self, a: Array) -> Array: ...
    def cast(self, a: Array, dtype: any) -> Array: ...
    def copy(self, a: Array) -> Array: ...

    def gather(self, a: Array, indices: Array, axis: int = 0) -> Array: ...
    def scatter(
        self, a: Array, indices: Array, values: Array, axis: int = 0
    ) -> Array: ...
    def take(self, a: Array, indices: Array, axis: int | None = None) -> Array: ...

    def memory_info(self, device: Device | None = None) -> dict[str, int]: ...
    def clear_cache(self, device: Device | None = None) -> None: ...


class AbstractBackend:
    """Base backend with common implementations."""

    name: str = "abstract"

    def full(
        self,
        shape: Shape,
        value: float,
        dtype: any = None,
        device: Device | None = None,
    ) -> Array:
        """Array filled with value."""
        ones = self.ones(shape, dtype=dtype, device=device)
        return self.mul(ones, value)

    def eye(self, n: int, m: int | None = None, device: Device | None = None) -> Array:
        """Identity matrix."""
        m = m or n
        eye = self.zeros((n, m), device=device)
        # TODO: Implement proper eye matrix initialization
        # idx = self.arange(min(n, m), device=device)
        return eye

    def zeros_like(self, a: Array) -> Array:
        """Zeros with same shape/dtype."""
        return self.zeros(self.shape(a), dtype=self.dtype(a), device=self.device(a))

    def ones_like(self, a: Array) -> Array:
        """Ones with same shape/dtype."""
        return self.ones(self.shape(a), dtype=self.dtype(a), device=self.device(a))

    def copy(self, a: Array) -> Array:
        """Copy array."""
        return self.add(a, self.zeros_like(a))
